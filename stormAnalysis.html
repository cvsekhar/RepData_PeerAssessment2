<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Impact of Storm and Weather events on public health and economy</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}

pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Impact of Storm and Weather events on public health and economy</h1>

<h2>Synopsis</h2>

<p>In this report we try to show which storm and weather have a greater impact 
 on the public health and economic consequences for communties and muncipalities.
 Inorder to investigate this hypothesis we have gathered the data from
 U.S. National Oceanic and Atmospheric Administration&#39;s (NOAA) storm database.
 The events in the database start in the year 1950 and end in November 2011. 
 This database tracks characteristics of major storms and weather events in 
 the United States, including when and where they occur, as well as estimates 
 of any fatalities, injuries, and property damage. From this data taking the
 top 20 events, we found Tornado&#39;s are major danger to public health as it results
 in more fatalities and Injuries. Flood&#39;s on the other hand have major impact on
 economic consequences.</p>

<h2>Data Processing</h2>

<p>set global cache options for R </p>

<pre><code class="r"># set global options
opts_chunk$set(echo = TRUE, cache = TRUE, message = FALSE)
</code></pre>

<p>define a name for the bzip file and download the file</p>

<pre><code class="r">bzFilename &lt;- &quot;stomdata.bz2&quot;

fileUrl &lt;- &quot;https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2&quot;

download.file(fileUrl, destfile = bzFilename, method = &quot;curl&quot;)
</code></pre>

<p>load the data into a data variable by reading the download file using read.csv 
with a field seperator &ldquo;,&rdquo; and quote character &ldquo;\&rdquo;&ldquo;, but we need to bzfile
before passing it to read.csv function</p>

<pre><code class="r"># read data
data &lt;- read.csv(bzfile(bzFilename), sep = &quot;,&quot;, quote = &quot;\&quot;&quot;)

# print the column names
colnames(data)
</code></pre>

<pre><code>##  [1] &quot;STATE__&quot;    &quot;BGN_DATE&quot;   &quot;BGN_TIME&quot;   &quot;TIME_ZONE&quot;  &quot;COUNTY&quot;    
##  [6] &quot;COUNTYNAME&quot; &quot;STATE&quot;      &quot;EVTYPE&quot;     &quot;BGN_RANGE&quot;  &quot;BGN_AZI&quot;   
## [11] &quot;BGN_LOCATI&quot; &quot;END_DATE&quot;   &quot;END_TIME&quot;   &quot;COUNTY_END&quot; &quot;COUNTYENDN&quot;
## [16] &quot;END_RANGE&quot;  &quot;END_AZI&quot;    &quot;END_LOCATI&quot; &quot;LENGTH&quot;     &quot;WIDTH&quot;     
## [21] &quot;F&quot;          &quot;MAG&quot;        &quot;FATALITIES&quot; &quot;INJURIES&quot;   &quot;PROPDMG&quot;   
## [26] &quot;PROPDMGEXP&quot; &quot;CROPDMG&quot;    &quot;CROPDMGEXP&quot; &quot;WFO&quot;        &quot;STATEOFFIC&quot;
## [31] &quot;ZONENAMES&quot;  &quot;LATITUDE&quot;   &quot;LONGITUDE&quot;  &quot;LATITUDE_E&quot; &quot;LONGITUDE_&quot;
## [36] &quot;REMARKS&quot;    &quot;REFNUM&quot;
</code></pre>

<pre><code class="r">
# print the first few rows
head(data, 2)
</code></pre>

<pre><code>##   STATE__          BGN_DATE BGN_TIME TIME_ZONE COUNTY COUNTYNAME STATE
## 1       1 4/18/1950 0:00:00     0130       CST     97     MOBILE    AL
## 2       1 4/18/1950 0:00:00     0145       CST      3    BALDWIN    AL
##    EVTYPE BGN_RANGE BGN_AZI BGN_LOCATI END_DATE END_TIME COUNTY_END
## 1 TORNADO         0                                               0
## 2 TORNADO         0                                               0
##   COUNTYENDN END_RANGE END_AZI END_LOCATI LENGTH WIDTH F MAG FATALITIES
## 1         NA         0                        14   100 3   0          0
## 2         NA         0                         2   150 2   0          0
##   INJURIES PROPDMG PROPDMGEXP CROPDMG CROPDMGEXP WFO STATEOFFIC ZONENAMES
## 1       15    25.0          K       0                                    
## 2        0     2.5          K       0                                    
##   LATITUDE LONGITUDE LATITUDE_E LONGITUDE_ REMARKS REFNUM
## 1     3040      8812       3051       8806              1
## 2     3042      8755          0          0              2
</code></pre>

<h3>Transformations</h3>

<p>Filter and include only the values for the columns
FATALITIES , INJURIES,  PROPDMG and  CROPDMG when the values are greater than
zero</p>

<pre><code class="r">m &lt;- subset(data, FATALITIES &gt; 0 | INJURIES &gt; 0 | PROPDMG &gt; 0 | CROPDMG &gt; 0)
</code></pre>

<p>Convert all the values in EVTYPE column to upper case to clean the data</p>

<pre><code class="r">m[, c(&quot;EVTYPE&quot;)] &lt;- toupper(m[, c(&quot;EVTYPE&quot;)])
</code></pre>

<p>Clean most of the values by correcting and converting them to the
event types as described in 
<a href="https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf">https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf</a>.
so most of the identical event types are grouped together</p>

<pre><code class="r">
m[m$EVTYPE == &quot;AVALANCE&quot;, c(&quot;EVTYPE&quot;)] &lt;- &quot;AVALANCHE&quot;

m[grep(&quot;BLIZZARD*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;BLIZZARD&quot;

m[grep(&quot;HAIL*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HAIL&quot;

m[grep(&quot;HEAVY RAIN*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HEAVY RAIN&quot;

m[grep(&quot;WATERSPOUT*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;WATERSPOUT&quot;

m[grep(&quot;HURRICANE*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HURRICANE&quot;

m[grep(&quot;THUNDERSTORM*|TUNDERSTORM WIND*|TSTM WIND*|THUDERSTORM WINDS*&quot;, m$EVTYPE), 
    c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNDEERSTORM WINDS*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNDERESTORM WINDS*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNDERTORM WINDS*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNERSTORM WINDS*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNDERSTROM WIND*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;THUNDERSTROM WIND*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;TSTMW*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;THUNDERSTORM WIND&quot;

m[grep(&quot;TORNADO*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;TORNADO&quot;

m[grep(&quot;TORNDAO*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;TORNADO&quot;

m[grep(&quot;RIP CURRENT*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;RIP CURRENT&quot;

m[grep(&quot;STRONG WIND*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;STRONG WIND&quot;

m[grep(&quot;LIGHTNING*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;LIGHTNING&quot;

m[grep(&quot;LIGHTING*|LIGNTNING*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;LIGHTNING&quot;

m[grep(&quot;FLASH FLOOD*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;FLASH FLOOD&quot;

m[grep(&quot;WINTER WEATHER*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;WINTER WEATHER&quot;

m[grep(&quot;WINTER STORM*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;WINTER STORM&quot;

m[grep(&quot;TROPICAL STORM*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;TROPICAL STORM&quot;

m[grep(&quot;HEAVY SNOW*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HEAVY SNOW&quot;

m[grep(&quot;HEAVY RAIN*|HVY RAIN*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HEAVY RAIN&quot;

m[grep(&quot;FLOOD/FLASH*|FLOOD FLASH*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;FLASH FLOOD&quot;

m[grep(&quot;FLOODING|FLOOD/RIVER FLOOD|FLOODS|FLOOD/RAIN/WINDS&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;FLOOD&quot;

m[grep(&quot;WILDFIRES*|WILD FIRES*|WILDFIRE*|WILD/FOREST*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;WILDFIRE&quot;

m[grep(&quot;HURRICANE*|TYPHOON*&quot;, m$EVTYPE), c(&quot;EVTYPE&quot;)] &lt;- &quot;HURRICANE (TYPHOON)&quot;
</code></pre>

<p>Creating a marginal data frame for expense conversion to billions taking
billion as base line 0 becomes 1e-9 in terms of billions, 1 becomes 1e-8 in
terms of billions and so on and similarly for k the value is 1e-6 in terms of 
billions, for h the value is 1e-7 in terms of billions and 
for m the value is 1e-3 in terms of billions</p>

<pre><code class="r">mag &lt;- c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;k&quot;, &quot;K&quot;, &quot;m&quot;, &quot;M&quot;, &quot;b&quot;, &quot;B&quot;, &quot;h&quot;, &quot;H&quot;)

magv &lt;- c(1e-09, 1e-08, 1e-07, 1e-06, 1e-05, 1e-04, 0.001, 0.01, 0.1, 1, 1e-06, 
    1e-06, 0.001, 0.001, 1, 1, 1e-07, 1e-07)

magdf &lt;- data.frame(mag = mag, magv = magv)
</code></pre>

<p>Converting the factor values in CROPDMGEXP and PROPDMGEXP to values using
the marginal dataframe and adding the columns CROPDMGEXPV and PROPDMGEXP</p>

<pre><code class="r">cb &lt;- subset(m, m$PROPDMGEXP %in% magdf$mag | m$CROPDMGEXP %in% magdf$mag)

cb$CROPDMGEXPV &lt;- sapply(cb$CROPDMGEXP, function(x) {
    if (x %in% magdf$mag) 
        magdf[mag == x, 2] else 0
})

cb$PROPDMGEXPV &lt;- sapply(cb$PROPDMGEXP, function(x) {
    if (x %in% magdf$mag) 
        magdf[mag == x, 2] else 0
})
</code></pre>

<p>Adding the values (CROPDMG * CROPDMGEXPV) and (PROPDMG * PROPDMGEXPV)
to create TOTLEXP column</p>

<pre><code class="r">cb &lt;- transform(cb, TOTLEXP = CROPDMG * CROPDMGEXPV + PROPDMG * PROPDMGEXPV)
</code></pre>

<h2>Results</h2>

<h3>Most harmful events to population health</h3>

<p>The most harmful events to population health can be assessed by taking the
top twenty event types for fatalities and injuries</p>

<h4>Using Fatalities to see the most damaging events for population health</h4>

<p>We calculate the total fatalities for each event type</p>

<pre><code class="r">tf &lt;- tapply(cb$FATALITIES, cb$EVTYPE, sum)

# creating a data frame which we can use
tfdf &lt;- data.frame(eventtype = names(tf), fat = as.numeric(tf))

# order by fatalities descending
tfdf &lt;- tfdf[order(tfdf$fat, decreasing = TRUE), ]

# take top 20
tfdf &lt;- tfdf[1:20, ]

print(tfdf)
</code></pre>

<pre><code>##                   eventtype  fat
## 168                 TORNADO 5591
## 42              FLASH FLOOD  768
## 43                    FLOOD  413
## 167       THUNDERSTORM WIND  357
## 66                     HEAT  227
## 115               LIGHTNING  222
## 135             RIP CURRENT  216
## 33           EXCESSIVE HEAT  188
## 84                HIGH WIND  166
## 96      HURRICANE (TYPHOON)  109
## 6                 AVALANCHE  103
## 192            WINTER STORM  100
## 18          COLD/WIND CHILL   94
## 165             STRONG WIND   91
## 186                WILDFIRE   79
## 8                  BLIZZARD   70
## 79                HIGH SURF   70
## 74               HEAVY SNOW   64
## 38  EXTREME COLD/WIND CHILL   60
## 170          TROPICAL STORM   56
</code></pre>

<p>We create a barplot showing the top 20 fatalities</p>

<pre><code class="r">par(mar = c(13, 7, 2, 2), las = 3)

barplot(tfdf$fat, names.arg = tfdf$eventtype, col = tfdf$eventtype, ylab = &quot;Total Fatalities&quot;, 
    main = &quot;Top 20 Total Fatalities per Event Type&quot;)

title(xlab = &quot;Event Type&quot;, line = 11)
</code></pre>

<p><img src="figure/barplotfatalities.png" alt="plot of chunk barplotfatalities"/> </p>

<h4>Using Injuries to see the most damaging events for population health</h4>

<p>We calculate the total injuries for each event type</p>

<pre><code class="r">inj &lt;- tapply(cb$INJURIES, cb$EVTYPE, sum)

# creating a data frame which we can use
injdf &lt;- data.frame(eventtype = names(inj), inju = as.numeric(inj))

# order by fatalities descending
injdf &lt;- injdf[order(injdf$inju, decreasing = TRUE), ]

# take top 20
injdf &lt;- injdf[1:20, ]

print(injdf)
</code></pre>

<pre><code>##               eventtype  inju
## 168             TORNADO 90472
## 43                FLOOD  6754
## 167   THUNDERSTORM WIND  4977
## 103           ICE STORM  1847
## 115           LIGHTNING  1599
## 42          FLASH FLOOD  1570
## 66                 HEAT  1554
## 96  HURRICANE (TYPHOON)  1328
## 186            WILDFIRE  1328
## 192        WINTER STORM  1059
## 33       EXCESSIVE HEAT   949
## 84            HIGH WIND   927
## 74           HEAVY SNOW   787
## 8              BLIZZARD   779
## 64                 HAIL   720
## 44                  FOG   455
## 170      TROPICAL STORM   380
## 193      WINTER WEATHER   374
## 22            DENSE FOG   254
## 165         STRONG WIND   246
</code></pre>

<p>We create a barplot showing the top 20 fatalities</p>

<pre><code class="r">par(mar = c(13, 7, 2, 2), las = 3)

barplot(injdf$inju, names.arg = injdf$eventtype, col = injdf$eventtype, ylab = &quot;Total Injuries&quot;, 
    main = &quot;Top 20 Total Injuries per Event Type&quot;)

title(xlab = &quot;Event Type&quot;, line = 11)
</code></pre>

<p><img src="figure/barplotinjuries.png" alt="plot of chunk barplotinjuries"/> </p>

<p>From this fatalities graph and injuries graph it shows <strong>TORNADO&#39;s</strong> 
have a great impact on the population health</p>

<h3>Assessing which event has greatest economic consequence</h3>

<p>First we group the total exp (CROPEXP * CROPDMG+ PROPEXP * PROPDMG) by event type 
and order the rows by exp decreasing and take the top 20 events that contributed 
to more economic consequences. There is a caveat here I haven&#39;t considered the 
deflation of money across the years</p>

<pre><code class="r">ae &lt;- tapply(cb$TOTLEXP, cb$EVTYPE, sum)

# creating a data frame which we can use
aedf &lt;- data.frame(eventtype = names(ae), exp = as.numeric(ae))

# order by expense descending
aedf &lt;- aedf[order(aedf$exp, decreasing = TRUE), ]

# take top 20
aedf &lt;- aedf[1:20, ]

print(aedf)
</code></pre>

<pre><code>##               eventtype      exp
## 43                FLOOD 150.8907
## 96  HURRICANE (TYPHOON)  90.8725
## 168             TORNADO  57.3671
## 163         STORM SURGE  43.3235
## 64                 HAIL  20.7372
## 42          FLASH FLOOD  19.1215
## 25              DROUGHT  15.0187
## 167   THUNDERSTORM WIND  12.3470
## 137         RIVER FLOOD  10.1484
## 103           ICE STORM   8.9670
## 186            WILDFIRE   8.8943
## 170      TROPICAL STORM   8.4093
## 192        WINTER STORM   6.7819
## 84            HIGH WIND   5.9086
## 164    STORM SURGE/TIDE   4.6420
## 72           HEAVY RAIN   4.0443
## 37         EXTREME COLD   1.3807
## 53         FROST/FREEZE   1.1047
## 74           HEAVY SNOW   1.0812
## 115           LIGHTNING   0.9475
</code></pre>

<p>Now we create a bar graph showing the top events that caused great economic
sequences</p>

<pre><code class="r">par(mar = c(13, 7, 2, 2), las = 3)

barplot(aedf$exp, names.arg = aedf$eventtype, col = aedf$eventtype, ylab = &quot;Total Expense in Billions&quot;, 
    main = &quot;Top 20 Total Expense in Billion per Event Type&quot;)

title(xlab = &quot;Event Typer&quot;, line = 11)
</code></pre>

<p><img src="figure/barexp.png" alt="plot of chunk barexp"/> </p>

<p>From the graph its clear that <strong>FLOOD&#39;s</strong> have a great economic consequence</p>

</body>

</html>
